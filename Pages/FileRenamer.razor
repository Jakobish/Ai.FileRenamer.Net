@page "/file-renamer"
@inject IJSRuntime JSRuntime
@inject FileDbContext DbContext
@inject IPdfService PdfService

<PageTitle>PDF File Renamer</PageTitle>


<div class="file-renamer-container">
    <h1 class="title">PDF File Renamer</h1>

    <div class="controls">
        <label for="filePicker">Select PDF Files:</label>
        <input type="file" id="filePicker" multiple accept=".pdf" @onchange="OnFilesSelected" disabled="@IsProcessing" />
        <button @onclick="ProcessFiles" class="scan-button" disabled="@(!Files.Any() || IsProcessing)">
            @if (IsProcessing)
            {
                <span>Processing... (@_processedCount of @Files.Count)</span>
            }
            else
            {
                <span>Process Files</span>
            }
        </button>
        @if (IsProcessing)
        {
            <button @onclick="CancelProcessing" class="cancel-button">Cancel</button>
        }
    </div>

    @if (_progress.IsProcessing)
    {
        <div class="progress-container">
            <div class="progress-info">
                <span>Overall Progress: @Math.Round(_progress.OverallProgress)%</span>
                <span>Current File: @_progress.CurrentFileName</span>
                <span>Status: @_progress.CurrentStatus</span>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" style="width: @(_progress.OverallProgress)%"></div>
            </div>
            <div class="batch-progress">
                <span>Current Batch: @_progress.CurrentBatchProcessed of @_progress.CurrentBatchSize</span>
                <div class="progress-bar-container">
                    <div class="progress-bar" style="width: @(_progress.BatchProgress)%"></div>
                </div>
            </div>
        </div>
    }

    @if (!string.IsNullOrEmpty(ErrorMessage))
    {
        <div class="alert alert-danger">
            @ErrorMessage
            <button @onclick="@(() => ErrorMessage = null)" class="close-button">Ã—</button>
        </div>
    }

    <div class="file-table" hidden="@(!Files.Any())">
        <table>
            <thead>
                <tr>
                    <th>#</th>
                    <th>File Name</th>
                    <th>Path</th>
                    <th>Suggested Name</th>
                    <th>Status</th>
                    <th>Actions</th>
                </tr>
            </thead>
            <tbody>
                @foreach (var file in Files)
                {
                    <tr>
                        <td>@file.Id</td>
                        <td>@file.FileName</td>
                        <td>@file.FilePath</td>
                        <td>@file.SuggestedName</td>
                        <td>
                            @if (file.Status == "Processing")
                            {
                                <div class="spinner"></div>
                            }
                            else
                            {
                                @file.Status
                            }
                        </td>
                        <td>
                            @if (file.Status == "Completed")
                            {
                                <button @onclick="() => ApplyRename(file)" class="rename-button">Apply</button>
                            }
                        </td>
                    </tr>
                }
            </tbody>
        </table>
    </div>

</div>

@code {
    private List<FileRecord> Files = new();
    private bool IsProcessing;
    private string? ErrorMessage;
    private int _processedCount;
    private CancellationTokenSource _cts = new();
    private ProgressState _progress = new();

    private async Task OnFilesSelected(ChangeEventArgs e)
    {
        try
        {
            Files.Clear();
            ErrorMessage = null;
            _progress.Reset();
            var fileInfos = await JSRuntime.InvokeAsync<FileInfo[]>("getPDFsFromFilePicker");
            
            if (fileInfos == null || !fileInfos.Any())
            {
                ErrorMessage = "No files selected.";
                return;
            }

            foreach (var fileInfo in fileInfos)
            {
                if (string.IsNullOrWhiteSpace(fileInfo.Name) || string.IsNullOrWhiteSpace(fileInfo.Path))
                {
                    ErrorMessage = "Invalid file information received.";
                    return;
                }

                if (!fileInfo.Name.EndsWith(".pdf", StringComparison.OrdinalIgnoreCase))
                {
                    ErrorMessage = $"File '{fileInfo.Name}' is not a PDF file. Only PDF files are supported.";
                    return;
                }

                Files.Add(new FileRecord
                {
                    Id = Files.Count + 1,
                    FileName = fileInfo.Name,
                    FilePath = fileInfo.Path,
                    SuggestedName = "",
                    Status = "Pending"
                });
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error selecting files: {ex.Message}";
            Files.Clear();
        }
    }

    private async Task ProcessFiles()
    {
        if (!Files.Any())
        {
            ErrorMessage = "No files to process.";
            return;
        }

        try
        {
            IsProcessing = true;
            _processedCount = 0;
            ErrorMessage = null;
            
            const int batchSize = 3;
            _progress.Initialize(Files.Count, batchSize);
            
            using (_cts = new CancellationTokenSource())
            {
                var pendingFiles = Files.Where(f => f.Status == "Pending").ToList();
                
                for (int i = 0; i < pendingFiles.Count; i += batchSize)
                {
                    if (_cts.Token.IsCancellationRequested)
                        break;

                    var batch = pendingFiles.Skip(i).Take(batchSize).ToList();
                    _progress.UpdateBatch(0, batch.Count);
                    
                    var tasks = batch.Select(ProcessSingleFile);
                    await Task.WhenAll(tasks);
                    
                    // Save changes after each batch
                    await DbContext.SaveChangesAsync(_cts.Token);
                }
            }
            
            _progress.Complete();
        }
        catch (OperationCanceledException)
        {
            ErrorMessage = "Operation was cancelled.";
            // Reset status for files that weren't processed
            foreach (var file in Files.Where(f => f.Status == "Processing"))
            {
                file.Status = "Pending";
            }
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error processing files: {ex.Message}";
        }
        finally
        {
            IsProcessing = false;
        }
    }

    private async Task ProcessSingleFile(FileRecord file)
    {
        if (file == null) return;

        try
        {
            file.Status = "Processing";
            _progress.UpdateProgress(file.FileName, "Processing");
            StateHasChanged();

            // Get the file bytes using JavaScript interop
            var fileBytes = await JSRuntime.InvokeAsync<byte[]>("getFileBytes", file.FilePath);
            _cts.Token.ThrowIfCancellationRequested();

            if (fileBytes == null || fileBytes.Length == 0)
            {
                throw new InvalidOperationException("File is empty or could not be read");
            }

            // Extract text from PDF
            var content = await PdfService.ExtractTextFromPdfAsync(fileBytes);
            _cts.Token.ThrowIfCancellationRequested();

            if (string.IsNullOrWhiteSpace(content))
            {
                throw new InvalidOperationException("No text could be extracted from the PDF");
            }

            // Get AI suggestion
            var suggestedName = await PdfService.GetSuggestedNameFromAIAsync(file.FileName, content);
            _cts.Token.ThrowIfCancellationRequested();

            if (string.IsNullOrWhiteSpace(suggestedName))
            {
                throw new InvalidOperationException("Could not generate a suggested name");
            }

            // Sanitize the suggested name
            suggestedName = string.Join("_", suggestedName.Split(Path.GetInvalidFileNameChars()));
            file.SuggestedName = suggestedName;
            file.Status = "Completed";
            _progress.UpdateProgress(file.FileName, "Completed");
            
            var existingFile = DbContext.Files.FirstOrDefault(f => f.FilePath == file.FilePath);
            if (existingFile != null)
            {
                DbContext.Entry(existingFile).CurrentValues.SetValues(file);
            }
            else
            {
                DbContext.Files.Add(file);
            }
            
            _processedCount++;
        }
        catch (Exception ex)
        {
            file.Status = "Error";
            file.SuggestedName = ex.Message;
            _progress.UpdateProgress(file.FileName, "Error");
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task CancelProcessing()
    {
        _cts.Cancel();
    }

    private async Task ApplyRename(FileRecord file)
    {
        if (file == null) return;

        try
        {
            var newFileName = Path.GetFileNameWithoutExtension(file.SuggestedName) + ".pdf";
            
            // In a web context, we'll just update the record
            file.FileName = newFileName;
            file.Status = "Renamed";
            
            await DbContext.SaveChangesAsync();
        }
        catch (Exception ex)
        {
            ErrorMessage = $"Error renaming file: {ex.Message}";
            file.Status = "Error";
        }
    }

    private class FileInfo
    {
        public string Name { get; set; } = "";
        public string Path { get; set; } = "";
    }
}